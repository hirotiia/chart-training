# パフォーマンスを上げるための施策

## データフェッチ

- サーバーキャッシュライブラリの導入検討
  - 自動キャッシュ、データの再検証、エラーハンドリングの面で恩恵があるため
- 不要なリクエストを減らす
- キャッシュの最適化
- AbortControllerで実行中の不要になったリクエストを途中で中止する

## ファイルサイズ

- css
  - `tailwind purge`でデプロイ時使わないクラスは削除する
  - `cssnano`でデプロイ時ファイルの圧縮を行う

## キャッシュ

参考：(Next.js公式ドキュメント キャッシュ より)[https://nextjs.org/docs/app/building-your-application/caching]

- Request Memoization (React：サーバーサイド)

  - React独自にfetch APIを拡張
  - GETメソッドで同じURLとオプションを持つリクエストを初期レンダリングや同じレンダリングサイクル内の間自動的にメモ化する。
    - ツリーの一番上（親）でデータを取得し、それをプロパティ（props）として子コンポーネントに渡していくみたいなことは不要
    - 同じデータに対して、ネットワークを通じて複数回リクエストを送るようなパフォーマンスの問題が発生しないようにできるため、各コンポーネントで個別にデータを取得しても、ネットワークへの負荷を心配する必要はない
    - Next.jsの機能であるルートハンドラでは使えない
  - メモ化の流れ
    - ルートをレンダリングしている間、最初にリクエストが呼び出されると、キャッシュMISS（キャッシュにデータがない状態）になる。
    - このため、関数が実行され、データが外部のソースから取得され、その結果がメモリに保存される。
    - 同じレンダリング中に再び同じリクエストが呼び出されると、今度はメモリにデータがあるので、キャッシュHIT（キャッシュにデータがある状態）になる。
    - キャッシュHITの場合、関数は再び実行されず、メモリから直接データが返される。
    - レンダリングが完了すると、メモリが`「リセット」`され、すべてのメモ化されたデータがクリアされる。

- Data Cache(Next：サーバーサイド)

  - `force-cache`で一度取りに行ったデータは再検証やオプトアウトされない限り、リクエストが来てもデプロイされてもキャッシュにデータが保存され続ける
    - くどいが何の場合もメモ化される
  - キャッシュの流れ
    - 初回のフェッチリクエスト時、Next.jsはデータキャッシュにキャッシュされたレスポンスがあるか確認する
    - キャッシュされたレスポンスが見つかれば、すぐに返され、メモ化（memoized）される
    - キャッシュが見つからなければ、データソースにリクエストを送り、結果をデータキャッシュに保存し、メモ化する
    - キャッシュしないデータ（例: { cache: 'no-store' }）の場合、毎回データソースから結果を取得し、メモ化する
    - キャッシュされたデータでも、キャッシュされていないデータでも、リクエストは常にメモ化され、同じレンダリングパス内で重複したリクエストを防ぐ
  - 再検証について
    - 時間ベースの再検証：一定時間が経過し、新たなリクエストが行われた後にデータを再検証する。
      - 変更頻度が低く、鮮度がそれほど重要でないデータに有効
    - オンデマンド再検証
      - タグベース: データにタグをつけておいて、そのタグに関連するデータをまとめて再取得するなど
        - たとえば、「ニュース」というタグをつけたすべての記事データを一度に更新する。
      - パスベース: ページのURLやパスごとにデータを再取得する。
        - 特定のURLに対応するページだけを再検証して、最新の情報を表示させる。
          - 最新のデータをできるだけ早く表示したい場合に便利（ヘッドレスCMSのコンテンツが更新された場合など）。

- Full Route Cache(Next：サーバーサイド)

  - ビルド時に特定のページ（ルート）全体をサーバー側でキャッシュする仕組み
    - サーバーにリクエストが来たときに毎回ページを生成せずに、キャッシュされた内容を返すことで、ページの読み込み速度を大幅に向上させる。
  - キャッシュの流れ
    - (サーバー)サーバーコンポーネントは、データを最適化された形式（React Server Component Payload:データを効率的に処理・送信するための形式）に変換されます。
    - (サーバー)次に、Next.jsがこのデータとクライアントコンポーネントのJavaScriptを使って、サーバーでHTMLを生成します。
    - (サーバー)サーバー上でルートのレンダリング結果（React Server Component PayloadとHTML）をキャッシュします。
      - これはビルド時の静的レンダリングや再検証時に適用されます。
    - (クライアント)リクエスト時、まずHTMLが表示され、素早いプレビューを提供します（まだ操作不可）。
    - (クライアント)React Server Component Payloadを使って、サーバーとクライアントのコンポーネントツリーが同期され、DOMが更新されます。
    - JavaScriptの指示でクライアントコンポーネントが操作可能になり、アプリがインタラクティブになります。（ハイドレーション）
    - クライアント側のルーターキャッシュには、サーバーコンポーネントのデータが保存されます
      - 以前訪れたページを保存
      - 次に訪れる可能性のあるページを事前に取得（プリフェッチ）することでページ遷移がよりスムーズになる
    - 次回以降のページ遷移や事前読み込み時、Next.jsはまずルーターキャッシュを確認します。
    - キャッシュにReact Server Component Payloadがあれば、新しいリクエストをサーバーに送らず、そのデータを使います。
    - キャッシュにない場合は、Next.jsがサーバーにリクエストを送り、データを取得します。
    - 取得したデータは、クライアント側のルーターキャッシュに保存され、次回以降の遷移に利用されます。

- Router Cache
  - クライアント側で個別のルートセグメント（React Server Component Payload）をキャッシュします。
    - 個別のルートセグメントとは、ページやアプリケーションの一部分（セグメント）に対応するコンポーネントのこと
  - キャッシュとレンダリングの流れ
    - キャッシュにより、戻る・進むナビゲーションが瞬時に行われる。
    - プリフェッチと部分レンダリングにより、新しいルートへの移動が速くなる。
    - ページ間の移動時にフルリロードはなく、Reactの状態やブラウザの状態も保持される。
