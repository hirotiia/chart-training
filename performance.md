# パフォーマンスを上げるための施策

## データフェッチ

- サーバーキャッシュライブラリの導入検討
  - 自動キャッシュ、データの再検証、エラーハンドリングの面で恩恵があるため
- 不要なリクエストを減らす
- キャッシュの最適化
- AbortControllerで実行中の不要になったリクエストを途中で中止する

## ファイルサイズ

- css
  - `tailwind purge`でデプロイ時使わないクラスは削除する
  - `cssnano`でデプロイ時ファイルの圧縮を行う

## キャッシュ

参考：(Next.js公式ドキュメント キャッシュ より)[https://nextjs.org/docs/app/building-your-application/caching]

- Request Memoization (React：サーバーサイド)

  - React独自にfetch APIを拡張
  - GETメソッドで同じURLとオプションを持つリクエストを初期レンダリングや同じレンダリングサイクル内の間自動的にメモ化する。
    - ツリーの一番上（親）でデータを取得し、それをプロパティ（props）として子コンポーネントに渡していくみたいなことは不要
    - 同じデータに対して、ネットワークを通じて複数回リクエストを送るようなパフォーマンスの問題が発生しないようにできるため、各コンポーネントで個別にデータを取得しても、ネットワークへの負荷を心配する必要はない
    - Next.jsの機能であるルートハンドラでは使えない
  - メモ化の流れ
    - ルートをレンダリングしている間、最初にリクエストが呼び出されると、キャッシュMISS（キャッシュにデータがない状態）になる。
    - このため、関数が実行され、データが外部のソースから取得され、その結果がメモリに保存される。
    - 同じレンダリング中に再び同じリクエストが呼び出されると、今度はメモリにデータがあるので、キャッシュHIT（キャッシュにデータがある状態）になる。
    - キャッシュHITの場合、関数は再び実行されず、メモリから直接データが返される。
    - レンダリングが完了すると、メモリが`「リセット」`され、すべてのメモ化されたデータがクリアされる。

- Data Cache(Next：サーバーサイド)
  - `force-cache`で一度取りに行ったデータはキャッシュに貯めておく
    - くどいが何の場合もメモ化される
  - キャッシュの流れ
    - 初回のフェッチリクエスト時、Next.jsはデータキャッシュにキャッシュされたレスポンスがあるか確認する
    - キャッシュされたレスポンスが見つかれば、すぐに返され、メモ化（memoized）される
    - キャッシュが見つからなければ、データソースにリクエストを送り、結果をデータキャッシュに保存し、メモ化する
    - キャッシュしないデータ（例: { cache: 'no-store' }）の場合、毎回データソースから結果を取得し、メモ化する
    - キャッシュされたデータでも、キャッシュされていないデータでも、リクエストは常にメモ化され、同じレンダリングパス内で重複したリクエストを防ぐ
